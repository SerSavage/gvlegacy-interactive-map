<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gloria Victis Interactive Map</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #000; color: #fff; overflow: hidden; }
        .topmenu { background: #333; padding: 10px; text-align: center; z-index: 1000; position: relative; }
        .topmenu a { color: #fff; text-decoration: none; margin: 0 15px; }
        .topmenu a:hover { color: #ffff00; }
        #map-container { 
        width: 100%;
            height: calc(100vh - 50px); 
            background: #1a1a1a; 
            overflow: auto;
    position: relative;
        }
        .layer-controls { 
            position: fixed;
            top: 60px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border: 2px solid #555;
            border-radius: 8px;
            z-index: 1000;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        .layer-controls h3 {
            color: #ffff00;
            margin-bottom: 10px;
            font-size: 16px;
            text-align: center;
        }
        .layer-controls label { 
            display: block;
            color: #fff;
            margin: 8px 0; 
            cursor: pointer;
            font-size: 14px;
            padding: 5px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .layer-controls label:hover {
            background: rgba(255, 255, 0, 0.1);
        }
        .layer-controls input[type="radio"] { 
            margin-right: 8px;
            cursor: pointer;
        }
        .layer-controls input[type="radio"]:checked + span {
            color: #ffff00;
            font-weight: bold;
        }
        #map-canvas {
    display: block;
            background: #1a1a1a;
        }
        .loading {
    position: absolute;
    top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
    color: #fff;
            font-size: 18px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="topmenu">
        <a href="#">Home</a>
        <a href="#">Interactive Map</a>
        <a href="#">Item Database</a>
        <a href="#">Workshop</a>
        <a href="#">Character Builder</a>
    </div>
    <div id="map-container">
        <div class="loading" id="loading">Loading map...</div>
        <canvas id="map-canvas"></canvas>
        <div class="layer-controls">
            <h3>Map Layers</h3>
            <label><input type="radio" name="layer" value="Main" checked><span>Main Map</span></label>
            <label><input type="radio" name="layer" value="GC1"><span>Guild Castle</span></label>
            <label><input type="radio" name="layer" value="ArenaTournament"><span>Arena/Tournament</span></label>
        </div>
    </div>
    <script>
        console.log('=== Gloria Victis Interactive Map ===');
        
        var TILE_SIZE = 512;  // Each tile is 512x512 pixels
        var availableAreas = ['Main', 'GC1', 'ArenaTournament'];
        var activeArea = 'Main';  // Currently displayed layer
        var loadingDiv = document.getElementById('loading');
        
        // Global search range for tiles
        var searchMinX = 0, searchMaxX = 20;
        var searchMinY = 0, searchMaxY = 17;
        
        // Layer-specific bounds (detected as tiles load)
        var layerBounds = {};
        availableAreas.forEach(function(area) {
            layerBounds[area] = { minX: null, maxX: null, minY: null, maxY: null };
        });
        
        // Current active layer bounds
        var minX = 0, maxX = 20;
        var minY = 0, maxY = 17;
        
        var canvas, ctx;
        var mapWidthPx, mapHeightPx;
        var loadedTiles = {};
        var loadingCount = 0;
        var totalToLoad = 0;
        var loadedCount = 0;
        var failedCount = 0;
        var drawnTiles = {}; // Track which tiles have been drawn
        var positionUsage = {}; // Track which tiles are drawn at each pixel position
        var currentScale = 1; // Track current zoom scale
        
        function resizeCanvasForLayer(area) {
            var bounds = layerBounds[area];
            
            // Wait for bounds to be detected
            if (bounds.minX === null) {
                // Use default bounds until tiles load
                minX = searchMinX;
                maxX = searchMaxX;
                minY = searchMinY;
                maxY = searchMaxY;
            } else {
                minX = bounds.minX;
                maxX = bounds.maxX;
                minY = bounds.minY;
                maxY = bounds.maxY;
            }
            
            var mapWidthTiles = maxX - minX + 1;
            var mapHeightTiles = maxY - minY + 1;
            mapWidthPx = mapWidthTiles * TILE_SIZE;
            mapHeightPx = mapHeightTiles * TILE_SIZE;
            
            console.log('=== Resizing Canvas for ' + area + ' ===');
            console.log('Tile range: X[' + minX + ' to ' + maxX + '], Y[' + minY + ' to ' + maxY + ']');
            console.log('Map size: ' + mapWidthTiles + 'x' + mapHeightTiles + ' tiles');
            console.log('Canvas size: ' + mapWidthPx + 'x' + mapHeightPx + ' pixels');
            
            // Resize canvas
            canvas.width = mapWidthPx;
            canvas.height = mapHeightPx;
            
            // Fill background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, mapWidthPx, mapHeightPx);
        }
        
        function initializeMap() {
            canvas = document.getElementById('map-canvas');
            ctx = canvas.getContext('2d');
            
            // Initialize with default bounds (will be updated as tiles load)
            resizeCanvasForLayer(activeArea);
            
            // Start loading tiles for all areas (preload)
            loadAllTiles();
            
            setupControls();
            setupLayerControls();
            
            // Center view (will be updated when bounds are known)
            var container = document.getElementById('map-container');
            setTimeout(function() {
                container.scrollLeft = mapWidthPx / 2 - container.clientWidth / 2;
                container.scrollTop = mapHeightPx / 2 - container.clientHeight / 2;
            }, 100);
        }
        
        function loadAllTiles() {
            var tilesToLoad = [];
            
            // Load tiles for all areas (preload all layers) - use search range
            for (var y = searchMinY; y <= searchMaxY; y++) {
                for (var x = searchMinX; x <= searchMaxX; x++) {
                    availableAreas.forEach(function(area) {
                        tilesToLoad.push({x: x, y: y, area: area});
                    });
                }
            }
            
            totalToLoad = tilesToLoad.length;
            console.log('Total tiles to load: ' + totalToLoad);
            console.log('First tile: x' + tilesToLoad[0].x + 'y' + tilesToLoad[0].y);
            console.log('Last tile: x' + tilesToLoad[tilesToLoad.length - 1].x + 'y' + tilesToLoad[tilesToLoad.length - 1].y);
            
            // Load all tiles - ensure proper order
            tilesToLoad.forEach(function(tile, index) {
                setTimeout(function() {
                    loadTile(tile.x, tile.y, tile.area, false);
                }, index * 2);
            });
        }
        
        function loadTile(x, y, area, debug) {
            var key = x + ',' + y + ',' + area;
            
            if (loadedTiles[key] !== undefined) return;
            
            loadingCount++;
            var img = new Image();
            var tilePath = '/GVmaptiles/x' + x + 'y' + y + '_' + area + '.png';
            
            img.onload = function() {
                loadedTiles[key] = img;
                loadingCount--;
                loadedCount++;
                
                // Update layer bounds for this area
                var bounds = layerBounds[area];
                if (bounds.minX === null || x < bounds.minX) bounds.minX = x;
                if (bounds.maxX === null || x > bounds.maxX) bounds.maxX = x;
                if (bounds.minY === null || y < bounds.minY) bounds.minY = y;
                if (bounds.maxY === null || y > bounds.maxY) bounds.maxY = y;
                
                // Only draw if this is the active layer and bounds are set
                if (area === activeArea && bounds.minX !== null) {
                    // Use layer-specific bounds for coordinate calculation
                    var layerMinX = bounds.minX;
                    var layerMaxX = bounds.maxX;
                    var layerMaxY = bounds.maxY;
                    
                    // Coordinate system: X standard (0=left, 20=right), Y inverted (0=bottom, 17=top)
                    // x0y0 = bottom-left, x20y17 = top-right
                    var px = (x - layerMinX) * TILE_SIZE;  // X: relative to layer's minX
                    var py = (layerMaxY - y) * TILE_SIZE;  // Y: 0 at bottom, increases upward
                    
                    // Ensure we don't draw outside canvas
                    if (px >= 0 && px < mapWidthPx && py >= 0 && py < mapHeightPx) {
                        // Check for duplicate positions
                        var posKey = px + ',' + py;
                        if (positionUsage[posKey]) {
                            console.warn('DUPLICATE POSITION! x' + x + 'y' + y + ' at [' + px + ', ' + py + '] - already used by: ' + positionUsage[posKey]);
                        } else {
                            positionUsage[posKey] = 'x' + x + 'y' + y;
                        }
                        
                        // Draw tile directly
                        try {
                            ctx.drawImage(img, px, py);
                            drawnTiles[key] = true;
                        } catch (e) {
                            console.error('Error drawing tile x' + x + 'y' + y + ':', e);
                        }
                    } else {
                        console.error('Tile x' + x + 'y' + y + ' OUT OF BOUNDS at [' + px + ', ' + py + '] (canvas: ' + mapWidthPx + 'x' + mapHeightPx + ')');
                    }
                }
                
                updateProgress();
            };
            
            img.onerror = function() {
                loadedTiles[key] = null;
                loadingCount--;
                failedCount++;
                
                if (debug) {
                    console.warn('Failed to load: ' + tilePath);
                }
                
                updateProgress();
            };
            
            img.src = tilePath;
        }
        
        function updateProgress() {
            var total = loadedCount + failedCount;
            var percent = Math.round((total / totalToLoad) * 100);
            
            loadingDiv.textContent = 'Loading: ' + percent + '% (' + loadedCount + ' loaded, ' + failedCount + ' missing)';
            
            if (total >= totalToLoad && loadingCount === 0) {
                loadingDiv.style.display = 'none';
                console.log('=== Loading Complete ===');
                console.log('Successfully loaded: ' + loadedCount + ' tiles');
                console.log('Failed to load: ' + failedCount + ' tiles');
                console.log('Tiles drawn: ' + Object.keys(drawnTiles).length);
                console.log('Canvas size: ' + canvas.width + 'x' + canvas.height);
                
                // Check for missing tiles
                var expectedTiles = (maxX - minX + 1) * (maxY - minY + 1);
                console.log('Expected tiles: ' + expectedTiles);
                
                if (loadedCount < expectedTiles) {
                    console.warn('MISSING TILES: Expected ' + expectedTiles + ' but only loaded ' + loadedCount);
                }
                
                // Check if all positions have tiles for active area (use layer bounds if available)
                var bounds = layerBounds[activeArea];
                var checkMinX = bounds.minX !== null ? bounds.minX : minX;
                var checkMaxX = bounds.maxX !== null ? bounds.maxX : maxX;
                var checkMinY = bounds.minY !== null ? bounds.minY : minY;
                var checkMaxY = bounds.maxY !== null ? bounds.maxY : maxY;
                
                var missingPositions = [];
                for (var y = checkMinY; y <= checkMaxY; y++) {
                    for (var x = checkMinX; x <= checkMaxX; x++) {
                        var key = x + ',' + y + ',' + activeArea;
                        if (!drawnTiles[key] && loadedTiles[key] !== null) {
                            missingPositions.push('x' + x + 'y' + y);
                        }
                    }
                }
                if (missingPositions.length > 0) {
                    console.error('MISSING ' + missingPositions.length + ' tile positions!');
                    console.error('Missing: ' + missingPositions.slice(0, 50).join(', ') + (missingPositions.length > 50 ? '... (showing first 50)' : ''));
                    
                    // Group by row to see pattern
                    var byRow = {};
                    missingPositions.forEach(function(pos) {
                        var match = pos.match(/x(\d+)y(\d+)/);
                        if (match) {
                            var row = match[2];
                            if (!byRow[row]) byRow[row] = [];
                            byRow[row].push(pos);
                        }
                    });
                    console.error('Missing tiles by row:', byRow);
                } else {
                    console.log('âœ“ All 378 tile positions have been drawn!');
                }
            }
        }
        
        function setupControls() {
            var container = document.getElementById('map-container');
            
            container.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                // Get mouse position relative to container
                var rect = container.getBoundingClientRect();
                var mouseX = e.clientX - rect.left;
                var mouseY = e.clientY - rect.top;
                
                // Calculate the point on the canvas (before zoom) that's under the mouse
                var canvasX = (container.scrollLeft + mouseX) / currentScale;
                var canvasY = (container.scrollTop + mouseY) / currentScale;
                
                // Apply zoom
                var delta = e.deltaY > 0 ? 0.9 : 1.1;
                currentScale = Math.max(0.5, Math.min(3, currentScale * delta));
                
                // Update canvas scale
                canvas.style.transform = 'scale(' + currentScale + ')';
                canvas.style.transformOrigin = 'top left';
                
                // Adjust scroll to keep the same point under the mouse cursor
                container.scrollLeft = canvasX * currentScale - mouseX;
                container.scrollTop = canvasY * currentScale - mouseY;
            });
            
            var isDragging = false;
            var startX, startY, scrollLeft, scrollTop;
            
            container.addEventListener('mousedown', function(e) {
                isDragging = true;
                startX = e.pageX - container.offsetLeft;
                startY = e.pageY - container.offsetTop;
                scrollLeft = container.scrollLeft;
                scrollTop = container.scrollTop;
            });
            
            container.addEventListener('mouseleave', function() {
                isDragging = false;
            });
            
            container.addEventListener('mouseup', function() {
                isDragging = false;
            });
            
            container.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                e.preventDefault();
                var x = e.pageX - container.offsetLeft;
                var y = e.pageY - container.offsetTop;
                var walkX = (x - startX) * 2;
                var walkY = (y - startY) * 2;
                container.scrollLeft = scrollLeft - walkX;
                container.scrollTop = scrollTop - walkY;
            });
        }
        
        function setupLayerControls() {
            var radios = document.querySelectorAll('input[name="layer"]');
            
            radios.forEach(function(radio) {
                radio.addEventListener('change', function() {
                    if (this.checked) {
                        switchLayer(this.value);
                    }
                });
            });
        }
        
        function switchLayer(newArea) {
            if (newArea === activeArea) return;
            
            console.log('Switching layer from ' + activeArea + ' to ' + newArea);
            
            // Store current scroll position (relative to center)
            var container = document.getElementById('map-container');
            var oldScrollX = container.scrollLeft;
            var oldScrollY = container.scrollTop;
            var oldCenterX = oldScrollX + container.clientWidth / 2;
            var oldCenterY = oldScrollY + container.clientHeight / 2;
            
            // Get old canvas center in canvas coordinates
            var oldCanvasCenterX = oldCenterX / currentScale;
            var oldCanvasCenterY = oldCenterY / currentScale;
            
            activeArea = newArea;
            
            // Resize canvas for new layer
            resizeCanvasForLayer(activeArea);
            
            // Reset tracking
            drawnTiles = {};
            positionUsage = {};
            
            // Get bounds for the new layer
            var bounds = layerBounds[activeArea];
            if (bounds.minX === null) {
                console.warn('Bounds not yet detected for ' + activeArea + ', using search range');
                bounds.minX = searchMinX;
                bounds.maxX = searchMaxX;
                bounds.minY = searchMinY;
                bounds.maxY = searchMaxY;
            }
            
            // Redraw all tiles for the new active area
            var redrawnCount = 0;
            for (var y = bounds.minY; y <= bounds.maxY; y++) {
                for (var x = bounds.minX; x <= bounds.maxX; x++) {
                    var key = x + ',' + y + ',' + activeArea;
                    var img = loadedTiles[key];
                    
                    if (img && img.complete && img.naturalWidth > 0) {
                        // Coordinate system: X standard (0=left, 20=right), Y inverted (0=bottom, 17=top)
                        // Use layer-specific bounds for positioning
                        var px = (x - bounds.minX) * TILE_SIZE;
                        var py = (bounds.maxY - y) * TILE_SIZE;
                        
                        if (px >= 0 && px < mapWidthPx && py >= 0 && py < mapHeightPx) {
                            try {
                                ctx.drawImage(img, px, py);
                                drawnTiles[key] = true;
                                redrawnCount++;
                            } catch (e) {
                                console.error('Error drawing tile x' + x + 'y' + y + ':', e);
                            }
                        }
                    }
                }
            }
            
            // Adjust scroll to maintain relative position (center the view)
            var newCanvasCenterX = mapWidthPx / 2;
            var newCanvasCenterY = mapHeightPx / 2;
            container.scrollLeft = newCanvasCenterX * currentScale - container.clientWidth / 2;
            container.scrollTop = newCanvasCenterY * currentScale - container.clientHeight / 2;
            
            console.log('Switched to ' + activeArea + ' layer: ' + redrawnCount + ' tiles drawn');
            console.log('New canvas size: ' + mapWidthPx + 'x' + mapHeightPx);
        }
        
        initializeMap();
        console.log('Map initialized');
    </script>
  </body>
</html>
